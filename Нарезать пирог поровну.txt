Снова в институте  биоинформатики творятся чудеса....
Напишите программу, которая помогает найти это число. Программа должна считывать размеры команд 
(два положительных целых числа a и b, каждое число вводится на отдельной строке) и 
выводить наименьшее число d, которое делится на оба этих числа без остатка.
....празник в общем надо пирог нарезать по теории Евклида.
_________________________________________________________
n1, n2 = int(input()), int(input())
a = n1
b = n2
while a != 0 and b !=0:            # Решение через НОД (наименьший общий делитель)
    if a > b:
        a = a % b
    else:
        b = b % a
nod = a + b
print(int((n1 * n2) / nod))
________________________________________________________
a=int(input())
b=int(input())
m=a
if a==b:                                        # если оба значения (a и b) равны, выводим сразу это значение, и программа завершается.   
  print(m)                                     # иначе, при помощи цикла, прибавляем к одному из значений(a или b) его же значение,
else:                                           # а+а+... или b+b+...до тех пор, пока сумма не будет кратной введенным значениям a и b 
  while m%a!=0 or m%b!=0:          # ТАКОЙ способ позволяет не прерывать цикл. Ниже пояснение.
    m=m+a
  print(m)
                      # конструкция m%a!=0 or m%b!=0 - позволяет производить цикл до момента, когда оба условия одновременно
                      # станут False. Потому что помним(!!!), что цикл While работает только когда условие в нем True, если 
                      # становится False, то блок While перестает работать.        
                      # То есть, знаем что or - это суммирование(0+0=0, 0+1=1, 1+1=1), and - это умножение (0*0=0, 0*1=0, 1*1=1), 
                      # not - просто меняет значение на противоположное. В нашем примере у нас or. 
                      # Возвращаясь к нашему примеру m%a!=0 or m%b!=0, когда находится общее минимальное делимое число, то? 
                      # результат в условие станет следующий - False и False, то есть, False+False, плюсуем потому что or(помним) 
                      # а значит 0+0=0, а ноль это False, при котором циклл While прекращает свою работу.
                      # А пока он дошел до этого момента, он пербирал, к примеру, такие варианты, 
                      # как False+True=True, True+False=True, при которых цикл продолжал работать, потому как True.
______________________________________________________________________________________